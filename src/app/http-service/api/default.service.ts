/**
 * Custom Vision Training 1.2
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { Account } from '../model/account';
import { Domain } from '../model/domain';
import { DomainArray } from '../model/domainArray';
import { ExportArray } from '../model/exportArray';
import { ImageArray } from '../model/imageArray';
import { ImageCreateSummary } from '../model/imageCreateSummary';
import { ImageFileCreateBatch } from '../model/imageFileCreateBatch';
import { ImageIdCreateBatch } from '../model/imageIdCreateBatch';
import { ImagePredictionResult } from '../model/imagePredictionResult';
import { ImageTagCreateBatch } from '../model/imageTagCreateBatch';
import { ImageTagCreateSummary } from '../model/imageTagCreateSummary';
import { ImageUrl } from '../model/imageUrl';
import { ImageUrlCreateBatch } from '../model/imageUrlCreateBatch';
import { Iteration } from '../model/iteration';
import { IterationArray } from '../model/iterationArray';
import { IterationPerformance } from '../model/iterationPerformance';
import { ModelExport } from '../model/modelExport';
import { PredictionQuery } from '../model/predictionQuery';
import { PredictionQueryToken } from '../model/predictionQueryToken';
import { Project } from '../model/project';
import { ProjectArray } from '../model/projectArray';
import { Tag } from '../model/tag';
import { TagList } from '../model/tagList';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DefaultService {

    protected basePath = 'https://southcentralus.api.cognitive.microsoft.com/customvision/v1.2/Training';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * CreateImagesFromData
     * This API accepts body content as multipart/form-data and application/octet-stream. When using multipart  multiple image files can be sent at once, with a maximum of 64 files
     * @param projectId Format - uuid. The project id
     * @param imageData 
     * @param tagIds The tags ids with which to tag each image. Limited to 20
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createImagesFromData(projectId: string, imageData: string, tagIds?: string, observe?: 'body', reportProgress?: boolean): Observable<ImageCreateSummary>;
    public createImagesFromData(projectId: string, imageData: string, tagIds?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ImageCreateSummary>>;
    public createImagesFromData(projectId: string, imageData: string, tagIds?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ImageCreateSummary>>;
    public createImagesFromData(projectId: string, imageData: string, tagIds?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createImagesFromData.');
        }
        if (imageData === null || imageData === undefined) {
            throw new Error('Required parameter imageData was null or undefined when calling createImagesFromData.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (tagIds !== undefined) {
            queryParameters = queryParameters.set('tagIds', <any>tagIds);
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (imageData !== undefined) {
            formParams = formParams.append('imageData', <any>imageData) || formParams;
        }

        return this.httpClient.post<ImageCreateSummary>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/images`,
            convertFormParamsToString ? formParams.toString() : formParams,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * CreateImagesFromFiles
     * Add the provided batch of images to the set of training images
     * @param projectId Format - uuid. The project id
     * @param imageFileCreateBatch The batch of image files to add. Limited to 64 images and 20 tags per batch
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createImagesFromFiles(projectId: string, imageFileCreateBatch?: ImageFileCreateBatch, observe?: 'body', reportProgress?: boolean): Observable<ImageCreateSummary>;
    public createImagesFromFiles(projectId: string, imageFileCreateBatch?: ImageFileCreateBatch, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ImageCreateSummary>>;
    public createImagesFromFiles(projectId: string, imageFileCreateBatch?: ImageFileCreateBatch, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ImageCreateSummary>>;
    public createImagesFromFiles(projectId: string, imageFileCreateBatch?: ImageFileCreateBatch, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createImagesFromFiles.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ImageCreateSummary>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/images/files`,
            imageFileCreateBatch,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * CreateImagesFromPredictions
     * Add the specified predicted images to the set of training images
     * @param projectId Format - uuid. The project id
     * @param imageIdCreateBatch Image and tag ids. Limted to 64 images and 20 tags per batch
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createImagesFromPredictions(projectId: string, imageIdCreateBatch?: ImageIdCreateBatch, observe?: 'body', reportProgress?: boolean): Observable<ImageCreateSummary>;
    public createImagesFromPredictions(projectId: string, imageIdCreateBatch?: ImageIdCreateBatch, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ImageCreateSummary>>;
    public createImagesFromPredictions(projectId: string, imageIdCreateBatch?: ImageIdCreateBatch, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ImageCreateSummary>>;
    public createImagesFromPredictions(projectId: string, imageIdCreateBatch?: ImageIdCreateBatch, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createImagesFromPredictions.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ImageCreateSummary>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/images/predictions`,
            imageIdCreateBatch,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * CreateImagesFromUrls
     * Add the provided images urls to the set of training images
     * @param projectId Format - uuid. The project id
     * @param imageUrlCreateBatch Image urls and tag ids. Limited to 64 images and 20 tags per batch
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createImagesFromUrls(projectId: string, imageUrlCreateBatch?: ImageUrlCreateBatch, observe?: 'body', reportProgress?: boolean): Observable<ImageCreateSummary>;
    public createImagesFromUrls(projectId: string, imageUrlCreateBatch?: ImageUrlCreateBatch, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ImageCreateSummary>>;
    public createImagesFromUrls(projectId: string, imageUrlCreateBatch?: ImageUrlCreateBatch, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ImageCreateSummary>>;
    public createImagesFromUrls(projectId: string, imageUrlCreateBatch?: ImageUrlCreateBatch, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createImagesFromUrls.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ImageCreateSummary>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/images/urls`,
            imageUrlCreateBatch,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * CreateProject
     * Create a project
     * @param name Name of the project
     * @param description The description of the project
     * @param domainId Format - uuid. The id of the domain to use for this project. Defaults to General
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProject(name: string, description?: string, domainId?: string, observe?: 'body', reportProgress?: boolean): Observable<Project>;
    public createProject(name: string, description?: string, domainId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Project>>;
    public createProject(name: string, description?: string, domainId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Project>>;
    public createProject(name: string, description?: string, domainId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createProject.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (name !== undefined) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (description !== undefined) {
            queryParameters = queryParameters.set('description', <any>description);
        }
        if (domainId !== undefined) {
            queryParameters = queryParameters.set('domainId', <any>domainId);
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.post<Project>(`${this.basePath}/projects`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * CreateTag
     * Create a tag for the project
     * @param projectId Format - uuid. The project id
     * @param name The tag name
     * @param description Optional description for the tag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createTag(projectId: string, name: string, description?: string, observe?: 'body', reportProgress?: boolean): Observable<Tag>;
    public createTag(projectId: string, name: string, description?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tag>>;
    public createTag(projectId: string, name: string, description?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tag>>;
    public createTag(projectId: string, name: string, description?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createTag.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createTag.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (name !== undefined) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (description !== undefined) {
            queryParameters = queryParameters.set('description', <any>description);
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.post<Tag>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/tags`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * DeleteImageTags
     * Remove a set of tags from a set of images
     * @param projectId Format - uuid. The project id
     * @param imageIds Image ids. Limited to 64 images
     * @param tagIds Tags to be deleted from the specified images. Limted to 20 tags
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteImageTags(projectId: string, imageIds: string, tagIds: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteImageTags(projectId: string, imageIds: string, tagIds: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteImageTags(projectId: string, imageIds: string, tagIds: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteImageTags(projectId: string, imageIds: string, tagIds: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteImageTags.');
        }
        if (imageIds === null || imageIds === undefined) {
            throw new Error('Required parameter imageIds was null or undefined when calling deleteImageTags.');
        }
        if (tagIds === null || tagIds === undefined) {
            throw new Error('Required parameter tagIds was null or undefined when calling deleteImageTags.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (imageIds !== undefined) {
            queryParameters = queryParameters.set('imageIds', <any>imageIds);
        }
        if (tagIds !== undefined) {
            queryParameters = queryParameters.set('tagIds', <any>tagIds);
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/images/tags`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * DeleteImages
     * Delete images from the set of training images
     * @param projectId Format - uuid. The project id
     * @param imageIds Ids of the images to be deleted. Limted to 256 images per batch
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteImages(projectId: string, imageIds: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteImages(projectId: string, imageIds: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteImages(projectId: string, imageIds: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteImages(projectId: string, imageIds: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteImages.');
        }
        if (imageIds === null || imageIds === undefined) {
            throw new Error('Required parameter imageIds was null or undefined when calling deleteImages.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (imageIds !== undefined) {
            queryParameters = queryParameters.set('imageIds', <any>imageIds);
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/images`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * DeleteIteration
     * Delete a specific iteration of a project
     * @param projectId Format - uuid. The project id
     * @param iterationId Format - uuid. The iteration id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteIteration(projectId: string, iterationId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteIteration(projectId: string, iterationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteIteration(projectId: string, iterationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteIteration(projectId: string, iterationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteIteration.');
        }
        if (iterationId === null || iterationId === undefined) {
            throw new Error('Required parameter iterationId was null or undefined when calling deleteIteration.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/iterations/${encodeURIComponent(String(iterationId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * DeletePrediction
     * Delete a set of predicted images and their associated prediction results
     * @param projectId Format - uuid. The project id
     * @param ids The prediction ids. Limited to 64
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deletePrediction(projectId: string, ids: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deletePrediction(projectId: string, ids: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deletePrediction(projectId: string, ids: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deletePrediction(projectId: string, ids: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deletePrediction.');
        }
        if (ids === null || ids === undefined) {
            throw new Error('Required parameter ids was null or undefined when calling deletePrediction.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (ids !== undefined) {
            queryParameters = queryParameters.set('ids', <any>ids);
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/predictions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * DeleteProject
     * Delete a specific project
     * @param projectId Format - uuid. The project id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProject(projectId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteProject(projectId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteProject(projectId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteProject(projectId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteProject.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * DeleteTag
     * Delete a tag from the project
     * @param projectId Format - uuid. The project id
     * @param tagId Format - uuid. Id of the tag to be deleted
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteTag(projectId: string, tagId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteTag(projectId: string, tagId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteTag(projectId: string, tagId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteTag(projectId: string, tagId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteTag.');
        }
        if (tagId === null || tagId === undefined) {
            throw new Error('Required parameter tagId was null or undefined when calling deleteTag.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/tags/${encodeURIComponent(String(tagId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * ExportIteration
     * Export a trained iteration
     * @param projectId Format - uuid. The project id
     * @param iterationId Format - uuid. The iteration id
     * @param platform The target platform (coreml or tensorflow)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public exportIteration(projectId: string, iterationId: string, platform: string, observe?: 'body', reportProgress?: boolean): Observable<ModelExport>;
    public exportIteration(projectId: string, iterationId: string, platform: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelExport>>;
    public exportIteration(projectId: string, iterationId: string, platform: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelExport>>;
    public exportIteration(projectId: string, iterationId: string, platform: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling exportIteration.');
        }
        if (iterationId === null || iterationId === undefined) {
            throw new Error('Required parameter iterationId was null or undefined when calling exportIteration.');
        }
        if (platform === null || platform === undefined) {
            throw new Error('Required parameter platform was null or undefined when calling exportIteration.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (platform !== undefined) {
            queryParameters = queryParameters.set('platform', <any>platform);
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.post<ModelExport>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/iterations/${encodeURIComponent(String(iterationId))}/export`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * GetAccountInfo
     * Get basic information about your account
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAccountInfo(observe?: 'body', reportProgress?: boolean): Observable<Account>;
    public getAccountInfo(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Account>>;
    public getAccountInfo(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Account>>;
    public getAccountInfo(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Account>(`${this.basePath}/account`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * GetDomain
     * Get information about a specific domain
     * @param domainId Format - uuid. The id of the domain to get information about
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDomain(domainId: string, observe?: 'body', reportProgress?: boolean): Observable<Domain>;
    public getDomain(domainId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Domain>>;
    public getDomain(domainId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Domain>>;
    public getDomain(domainId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (domainId === null || domainId === undefined) {
            throw new Error('Required parameter domainId was null or undefined when calling getDomain.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Domain>(`${this.basePath}/domains/${encodeURIComponent(String(domainId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * GetDomains
     * Get a list of the available domains
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDomains(observe?: 'body', reportProgress?: boolean): Observable<DomainArray>;
    public getDomains(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DomainArray>>;
    public getDomains(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DomainArray>>;
    public getDomains(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<DomainArray>(`${this.basePath}/domains`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * GetExports
     * Get the list of exports for a specific iteration
     * @param projectId Format - uuid. The project id
     * @param iterationId Format - uuid. The iteration id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getExports(projectId: string, iterationId: string, observe?: 'body', reportProgress?: boolean): Observable<ExportArray>;
    public getExports(projectId: string, iterationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ExportArray>>;
    public getExports(projectId: string, iterationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ExportArray>>;
    public getExports(projectId: string, iterationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getExports.');
        }
        if (iterationId === null || iterationId === undefined) {
            throw new Error('Required parameter iterationId was null or undefined when calling getExports.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<ExportArray>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/iterations/${encodeURIComponent(String(iterationId))}/export`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * GetIteration
     * Get a specific iteration
     * @param projectId Format - uuid. The id of the project the iteration belongs to
     * @param iterationId Format - uuid. The id of the iteration to get
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getIteration(projectId: string, iterationId: string, observe?: 'body', reportProgress?: boolean): Observable<Iteration>;
    public getIteration(projectId: string, iterationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Iteration>>;
    public getIteration(projectId: string, iterationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Iteration>>;
    public getIteration(projectId: string, iterationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getIteration.');
        }
        if (iterationId === null || iterationId === undefined) {
            throw new Error('Required parameter iterationId was null or undefined when calling getIteration.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Iteration>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/iterations/${encodeURIComponent(String(iterationId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * GetIterationPerformance
     * Get detailed performance information about a trained iteration
     * @param projectId Format - uuid. The project id
     * @param iterationId Format - uuid. The id of the trained iteration
     * @param threshold Format - float. The 0 to 1 threshold to determine positive prediction
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getIterationPerformance(projectId: string, iterationId: string, threshold: number, observe?: 'body', reportProgress?: boolean): Observable<IterationPerformance>;
    public getIterationPerformance(projectId: string, iterationId: string, threshold: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IterationPerformance>>;
    public getIterationPerformance(projectId: string, iterationId: string, threshold: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IterationPerformance>>;
    public getIterationPerformance(projectId: string, iterationId: string, threshold: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getIterationPerformance.');
        }
        if (iterationId === null || iterationId === undefined) {
            throw new Error('Required parameter iterationId was null or undefined when calling getIterationPerformance.');
        }
        if (threshold === null || threshold === undefined) {
            throw new Error('Required parameter threshold was null or undefined when calling getIterationPerformance.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (threshold !== undefined) {
            queryParameters = queryParameters.set('threshold', <any>threshold);
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<IterationPerformance>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/iterations/${encodeURIComponent(String(iterationId))}/performance`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * GetIterations
     * Get iterations for the project
     * @param projectId Format - uuid. The project id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getIterations(projectId: string, observe?: 'body', reportProgress?: boolean): Observable<IterationArray>;
    public getIterations(projectId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IterationArray>>;
    public getIterations(projectId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IterationArray>>;
    public getIterations(projectId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getIterations.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<IterationArray>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/iterations`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * GetProject
     * Get a specific project
     * @param projectId Format - uuid. The id of the project to get
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProject(projectId: string, observe?: 'body', reportProgress?: boolean): Observable<Project>;
    public getProject(projectId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Project>>;
    public getProject(projectId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Project>>;
    public getProject(projectId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getProject.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Project>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * GetProjects
     * Get your projects
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProjects(observe?: 'body', reportProgress?: boolean): Observable<ProjectArray>;
    public getProjects(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProjectArray>>;
    public getProjects(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProjectArray>>;
    public getProjects(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<ProjectArray>(`${this.basePath}/projects`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * GetTag
     * Get information about a specific tag
     * @param projectId Format - uuid. The project this tag belongs to
     * @param tagId Format - uuid. The tag id
     * @param iterationId Format - uuid. The iteration to retrieve this tag from. Optional, defaults to current training set
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTag(projectId: string, tagId: string, iterationId?: string, observe?: 'body', reportProgress?: boolean): Observable<Tag>;
    public getTag(projectId: string, tagId: string, iterationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tag>>;
    public getTag(projectId: string, tagId: string, iterationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tag>>;
    public getTag(projectId: string, tagId: string, iterationId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getTag.');
        }
        if (tagId === null || tagId === undefined) {
            throw new Error('Required parameter tagId was null or undefined when calling getTag.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (iterationId !== undefined) {
            queryParameters = queryParameters.set('iterationId', <any>iterationId);
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Tag>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/tags/${encodeURIComponent(String(tagId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * GetTaggedImages
     * This API supports batching and range selection. By default it will only return first 50 images matching images.  Use the {take} and {skip} parameters to control how many images to return in a given batch.  The filtering is on an and/or relationship. For example, if the provided tag ids are for the \&quot;Dog\&quot; and  \&quot;Cat\&quot; tags, then only images tagged with Dog and/or Cat will be returned
     * @param projectId Format - uuid. The project id
     * @param iterationId Format - uuid. The iteration id. Defaults to workspace
     * @param tagIds An list of tags ids to filter the images. Defaults to all tagged images when null. Limited to 20
     * @param orderBy The ordering. Defaults to newest
     * @param take Format - int32. Maximum number of images to return. Defaults to 50, limited to 256
     * @param skip Format - int32. Number of images to skip before beginning the image batch. Defaults to 0
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTaggedImages(projectId: string, iterationId?: string, tagIds?: string, orderBy?: string, take?: number, skip?: number, observe?: 'body', reportProgress?: boolean): Observable<ImageArray>;
    public getTaggedImages(projectId: string, iterationId?: string, tagIds?: string, orderBy?: string, take?: number, skip?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ImageArray>>;
    public getTaggedImages(projectId: string, iterationId?: string, tagIds?: string, orderBy?: string, take?: number, skip?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ImageArray>>;
    public getTaggedImages(projectId: string, iterationId?: string, tagIds?: string, orderBy?: string, take?: number, skip?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getTaggedImages.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (iterationId !== undefined) {
            queryParameters = queryParameters.set('iterationId', <any>iterationId);
        }
        if (tagIds !== undefined) {
            queryParameters = queryParameters.set('tagIds', <any>tagIds);
        }
        if (orderBy !== undefined) {
            queryParameters = queryParameters.set('orderBy', <any>orderBy);
        }
        if (take !== undefined) {
            queryParameters = queryParameters.set('take', <any>take);
        }
        if (skip !== undefined) {
            queryParameters = queryParameters.set('skip', <any>skip);
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<ImageArray>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/images/tagged`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * GetTags
     * Get the tags for a given project and iteration
     * @param projectId Format - uuid. The project id
     * @param iterationId Format - uuid. The iteration id. Defaults to workspace
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTags(projectId: string, iterationId?: string, observe?: 'body', reportProgress?: boolean): Observable<TagList>;
    public getTags(projectId: string, iterationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TagList>>;
    public getTags(projectId: string, iterationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TagList>>;
    public getTags(projectId: string, iterationId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getTags.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (iterationId !== undefined) {
            queryParameters = queryParameters.set('iterationId', <any>iterationId);
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TagList>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/tags`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * GetUntaggedImages
     * This API supports batching and range selection. By default it will only return first 50 images matching images.  Use the {take} and {skip} parameters to control how many images to return in a given batch.
     * @param projectId Format - uuid. The project id
     * @param iterationId Format - uuid. The iteration id. Defaults to workspace
     * @param orderBy The ordering. Defaults to newest
     * @param take Format - int32. Maximum number of images to return. Defaults to 50, limited to 256
     * @param skip Format - int32. Number of images to skip before beginning the image batch. Defaults to 0
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUntaggedImages(projectId: string, iterationId?: string, orderBy?: string, take?: number, skip?: number, observe?: 'body', reportProgress?: boolean): Observable<ImageArray>;
    public getUntaggedImages(projectId: string, iterationId?: string, orderBy?: string, take?: number, skip?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ImageArray>>;
    public getUntaggedImages(projectId: string, iterationId?: string, orderBy?: string, take?: number, skip?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ImageArray>>;
    public getUntaggedImages(projectId: string, iterationId?: string, orderBy?: string, take?: number, skip?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getUntaggedImages.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (iterationId !== undefined) {
            queryParameters = queryParameters.set('iterationId', <any>iterationId);
        }
        if (orderBy !== undefined) {
            queryParameters = queryParameters.set('orderBy', <any>orderBy);
        }
        if (take !== undefined) {
            queryParameters = queryParameters.set('take', <any>take);
        }
        if (skip !== undefined) {
            queryParameters = queryParameters.set('skip', <any>skip);
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<ImageArray>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/images/untagged`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * PostImageTags
     * Associate a set of images with a set of tags
     * @param projectId Format - uuid. The project id
     * @param imageTagCreateBatch Batch of image tags. Limited to 128 tags per batch
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postImageTags(projectId: string, imageTagCreateBatch?: ImageTagCreateBatch, observe?: 'body', reportProgress?: boolean): Observable<ImageTagCreateSummary>;
    public postImageTags(projectId: string, imageTagCreateBatch?: ImageTagCreateBatch, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ImageTagCreateSummary>>;
    public postImageTags(projectId: string, imageTagCreateBatch?: ImageTagCreateBatch, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ImageTagCreateSummary>>;
    public postImageTags(projectId: string, imageTagCreateBatch?: ImageTagCreateBatch, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling postImageTags.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ImageTagCreateSummary>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/images/tags`,
            imageTagCreateBatch,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * QueryPredictionResults
     * Get images that were sent to your prediction endpoint
     * @param projectId Format - uuid. The project id
     * @param predictionQueryToken Parameters used to query the predictions. Limited to combining 2 tags
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryPredictionResults(projectId: string, predictionQueryToken?: PredictionQueryToken, observe?: 'body', reportProgress?: boolean): Observable<PredictionQuery>;
    public queryPredictionResults(projectId: string, predictionQueryToken?: PredictionQueryToken, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PredictionQuery>>;
    public queryPredictionResults(projectId: string, predictionQueryToken?: PredictionQueryToken, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PredictionQuery>>;
    public queryPredictionResults(projectId: string, predictionQueryToken?: PredictionQueryToken, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling queryPredictionResults.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<PredictionQuery>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/predictions/query`,
            predictionQueryToken,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * QuickTestImage
     * Quick test an image
     * @param projectId Format - uuid. The project id
     * @param imageData 
     * @param iterationId Format - uuid. Optional. Specifies the id of a particular iteration to evaluate against.              The default iteration for the project will be used when not specified.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public quickTestImage(projectId: string, imageData: string, iterationId?: string, observe?: 'body', reportProgress?: boolean): Observable<ImagePredictionResult>;
    public quickTestImage(projectId: string, imageData: string, iterationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ImagePredictionResult>>;
    public quickTestImage(projectId: string, imageData: string, iterationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ImagePredictionResult>>;
    public quickTestImage(projectId: string, imageData: string, iterationId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling quickTestImage.');
        }
        if (imageData === null || imageData === undefined) {
            throw new Error('Required parameter imageData was null or undefined when calling quickTestImage.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (iterationId !== undefined) {
            queryParameters = queryParameters.set('iterationId', <any>iterationId);
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (imageData !== undefined) {
            formParams = formParams.append('imageData', <any>imageData) || formParams;
        }

        return this.httpClient.post<ImagePredictionResult>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/quicktest/image`,
            convertFormParamsToString ? formParams.toString() : formParams,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * QuickTestImageUrl
     * Quick test an image url
     * @param projectId Format - uuid. The project to evaluate against
     * @param iterationId Format - uuid. Optional. Specifies the id of a particular iteration to evaluate against.              The default iteration for the project will be used when not specified.
     * @param imageUrl An {Iris.Web.Api.Models.ImageUrl} that contains the url of the image to be evaluated
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public quickTestImageUrl(projectId: string, iterationId?: string, imageUrl?: ImageUrl, observe?: 'body', reportProgress?: boolean): Observable<ImagePredictionResult>;
    public quickTestImageUrl(projectId: string, iterationId?: string, imageUrl?: ImageUrl, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ImagePredictionResult>>;
    public quickTestImageUrl(projectId: string, iterationId?: string, imageUrl?: ImageUrl, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ImagePredictionResult>>;
    public quickTestImageUrl(projectId: string, iterationId?: string, imageUrl?: ImageUrl, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling quickTestImageUrl.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (iterationId !== undefined) {
            queryParameters = queryParameters.set('iterationId', <any>iterationId);
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ImagePredictionResult>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/quicktest/url`,
            imageUrl,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * TrainProject
     * Queues project for training
     * @param projectId Format - uuid. The project id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public trainProject(projectId: string, observe?: 'body', reportProgress?: boolean): Observable<Iteration>;
    public trainProject(projectId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Iteration>>;
    public trainProject(projectId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Iteration>>;
    public trainProject(projectId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling trainProject.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.post<Iteration>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/train`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * UpdateIteration
     * Update a specific iteration
     * @param projectId Format - uuid. Project id
     * @param iterationId Format - uuid. Iteration id
     * @param iteration The updated iteration model
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateIteration(projectId: string, iterationId: string, iteration?: Iteration, observe?: 'body', reportProgress?: boolean): Observable<Iteration>;
    public updateIteration(projectId: string, iterationId: string, iteration?: Iteration, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Iteration>>;
    public updateIteration(projectId: string, iterationId: string, iteration?: Iteration, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Iteration>>;
    public updateIteration(projectId: string, iterationId: string, iteration?: Iteration, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateIteration.');
        }
        if (iterationId === null || iterationId === undefined) {
            throw new Error('Required parameter iterationId was null or undefined when calling updateIteration.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.patch<Iteration>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/iterations/${encodeURIComponent(String(iterationId))}`,
            iteration,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * UpdateProject
     * Update a specific project
     * @param projectId Format - uuid. The id of the project to update
     * @param project The updated project model
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProject(projectId: string, project?: Project, observe?: 'body', reportProgress?: boolean): Observable<Project>;
    public updateProject(projectId: string, project?: Project, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Project>>;
    public updateProject(projectId: string, project?: Project, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Project>>;
    public updateProject(projectId: string, project?: Project, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateProject.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.patch<Project>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}`,
            project,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * UpdateTag
     * Update a tag
     * @param projectId Format - uuid. The project id
     * @param tagId Format - uuid. The id of the target tag
     * @param tag The updated tag model
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTag(projectId: string, tagId: string, tag?: Tag, observe?: 'body', reportProgress?: boolean): Observable<Tag>;
    public updateTag(projectId: string, tagId: string, tag?: Tag, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tag>>;
    public updateTag(projectId: string, tagId: string, tag?: Tag, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tag>>;
    public updateTag(projectId: string, tagId: string, tag?: Tag, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateTag.');
        }
        if (tagId === null || tagId === undefined) {
            throw new Error('Required parameter tagId was null or undefined when calling updateTag.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyHeader) required
        if (this.configuration.apiKeys["Training-key"]) {
            headers = headers.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // authentication (apiKeyQuery) required
        if (this.configuration.apiKeys["Training-key"]) {
            queryParameters = queryParameters.set('Training-key', this.configuration.apiKeys["Training-key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.patch<Tag>(`${this.basePath}/projects/${encodeURIComponent(String(projectId))}/tags/${encodeURIComponent(String(tagId))}`,
            tag,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
